import type { FutureToolsTool } from "./futuretools-scraper";
import { generateSlug } from "@/lib/utils/generate-slug";

export interface AutoGeneratedToolData {
  slug: string;
  category: string | null;
  features: string[] | null;
  pricingModel: string | null;
  needsReview: boolean;
  reviewReason: string | null;
}

/**
 * Auto-generates tool metadata from scraped data
 * Similar to how aitoolfinder.io generates tool data
 */
export function autoGenerateToolData(
  scrapedTool: FutureToolsTool
): AutoGeneratedToolData {
  const result: AutoGeneratedToolData = {
    slug: "",
    category: null,
    features: [],
    pricingModel: null,
    needsReview: false,
    reviewReason: null,
  };

  // 1. Generate slug from name
  result.slug = generateSlug(scrapedTool.name);

  // 2. Extract category (if available from scraped data)
  result.category = scrapedTool.category || null;

  // 3. Extract features from description
  result.features = extractFeatures(scrapedTool.description);

  // 4. Infer pricing model from description/keywords
  result.pricingModel = inferPricingModel(scrapedTool.description, scrapedTool.name);

  // 5. Determine if tool needs review
  const reviewCheck = checkNeedsReview(scrapedTool);
  result.needsReview = reviewCheck.needsReview;
  result.reviewReason = reviewCheck.reason;

  return result;
}

/**
 * Extract features from description
 * Looks for bullet points, key phrases, and important capabilities
 */
function extractFeatures(description: string): string[] {
  if (!description || description.trim().length === 0) {
    return [];
  }

  const features: string[] = [];

  // Method 1: Look for bullet points or list items
  const bulletPatterns = [
    /[-â€¢*]\s*(.+?)(?=\n|$)/g,
    /\d+[\.\)]\s*(.+?)(?=\n|$)/g,
  ];

  for (const pattern of bulletPatterns) {
    const matches = description.matchAll(pattern);
    for (const match of matches) {
      const feature = match[1]?.trim();
      if (feature && feature.length > 10 && feature.length < 200) {
        features.push(feature);
      }
    }
  }

  // Method 2: Split by sentences and extract key phrases
  if (features.length === 0) {
    const sentences = description
      .split(/[.!?]\s+/)
      .filter((s) => s.length > 20 && s.length < 200);

    // Look for sentences with action verbs or key capabilities
    const actionKeywords = [
      "allows",
      "enables",
      "provides",
      "offers",
      "supports",
      "includes",
      "features",
      "can",
      "lets",
    ];

    for (const sentence of sentences) {
      const lowerSentence = sentence.toLowerCase();
      if (actionKeywords.some((keyword) => lowerSentence.includes(keyword))) {
        features.push(sentence.trim());
      }
    }

    // If still no features, take first 3-5 meaningful sentences
    if (features.length === 0 && sentences.length > 0) {
      features.push(...sentences.slice(0, 5));
    }
  }

  // Method 3: Extract key phrases using common patterns
  const keyPhrasePatterns = [
    /(?:with|using|via|through)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/g,
    /(?:AI|artificial intelligence|machine learning|ML|NLP|GPT|LLM)/gi,
  ];

  for (const pattern of keyPhrasePatterns) {
    const matches = description.matchAll(pattern);
    for (const match of matches) {
      const phrase = match[0]?.trim();
      if (phrase && phrase.length > 3 && phrase.length < 50) {
        if (!features.some((f) => f.toLowerCase().includes(phrase.toLowerCase()))) {
          features.push(phrase);
        }
      }
    }
  }

  // Limit to 10 features max
  return features.slice(0, 10);
}

/**
 * Infer pricing model from description and name
 * Looks for keywords indicating pricing structure
 */
function inferPricingModel(description: string, name: string): string | null {
  const text = `${description} ${name}`.toLowerCase();

  // Free tier indicators
  if (
    text.includes("free") ||
    text.includes("free tier") ||
    text.includes("free plan") ||
    text.includes("free forever") ||
    text.includes("open source") ||
    text.includes("open-source")
  ) {
    // Check if it's completely free or freemium
    if (
      text.includes("premium") ||
      text.includes("pro") ||
      text.includes("paid") ||
      text.includes("subscription") ||
      text.includes("upgrade")
    ) {
      return "freemium";
    }
    return "free";
  }

  // Paid indicators
  if (
    text.includes("paid") ||
    text.includes("subscription") ||
    text.includes("pricing") ||
    text.includes("plan") ||
    text.includes("tier")
  ) {
    // Check for one-time payment
    if (
      text.includes("one-time") ||
      text.includes("one time") ||
      text.includes("lifetime") ||
      text.includes("single payment")
    ) {
      return "one-time";
    }
    return "paid";
  }

  // Freemium indicators
  if (
    text.includes("freemium") ||
    text.includes("free trial") ||
    text.includes("trial") ||
    (text.includes("free") && text.includes("premium"))
  ) {
    return "freemium";
  }

  // Default: unknown (will need admin review)
  return null;
}

/**
 * Check if tool needs admin review
 * Based on data completeness and quality
 */
function checkNeedsReview(scrapedTool: FutureToolsTool): {
  needsReview: boolean;
  reason: string | null;
} {
  const reasons: string[] = [];

  // Check for missing critical data
  if (!scrapedTool.description || scrapedTool.description.trim().length < 20) {
    reasons.push("Missing or incomplete description");
  }

  if (!scrapedTool.logoUrl) {
    reasons.push("Missing logo/image");
  }

  if (!scrapedTool.category) {
    reasons.push("Missing category");
  }

  // Check for low-quality data
  if (scrapedTool.description && scrapedTool.description.length < 50) {
    reasons.push("Description too short");
  }

  // Check for suspicious URLs
  if (
    scrapedTool.websiteUrl.includes("futuretools.link") ||
    scrapedTool.websiteUrl.includes("placeholder") ||
    !scrapedTool.websiteUrl.startsWith("http")
  ) {
    reasons.push("Invalid or placeholder website URL");
  }

  // Check for duplicate-like names
  if (scrapedTool.name.length < 3) {
    reasons.push("Tool name too short");
  }

  return {
    needsReview: reasons.length > 0,
    reason: reasons.length > 0 ? reasons.join("; ") : null,
  };
}

/**
 * Enhance tool description with additional context
 * Can be used to improve descriptions before saving
 */
export function enhanceDescription(
  description: string,
  name: string,
  category: string | null
): string {
  if (!description || description.trim().length === 0) {
    // Generate a basic description if missing
    return `${name} is an AI tool${category ? ` in the ${category} category` : ""}.`;
  }

  // Ensure description ends with proper punctuation
  let enhanced = description.trim();
  if (!/[.!?]$/.test(enhanced)) {
    enhanced += ".";
  }

  // Capitalize first letter
  enhanced = enhanced.charAt(0).toUpperCase() + enhanced.slice(1);

  return enhanced;
}

/**
 * Generate default category suggestions based on description/keywords
 * Can help when category is missing
 */
export function suggestCategory(description: string, name: string): string[] {
  const text = `${description} ${name}`.toLowerCase();
  const suggestions: string[] = [];

  // Category keyword mapping
  const categoryKeywords: Record<string, string[]> = {
    "Text Generation": [
      "text",
      "writing",
      "content",
      "article",
      "blog",
      "copy",
      "generator",
      "gpt",
      "llm",
      "language model",
    ],
    "Image Generation": [
      "image",
      "picture",
      "photo",
      "art",
      "design",
      "visual",
      "dall-e",
      "midjourney",
      "stable diffusion",
    ],
    "Code Generation": [
      "code",
      "programming",
      "developer",
      "coding",
      "script",
      "function",
      "api",
      "sdk",
    ],
    "Video Generation": [
      "video",
      "animation",
      "film",
      "movie",
      "clip",
      "youtube",
    ],
    "Audio Generation": [
      "audio",
      "sound",
      "music",
      "voice",
      "speech",
      "podcast",
    ],
    "Productivity": [
      "productivity",
      "task",
      "project",
      "management",
      "organize",
      "workflow",
    ],
    "Business": [
      "business",
      "enterprise",
      "sales",
      "marketing",
      "customer",
      "crm",
    ],
    "Education": [
      "education",
      "learning",
      "course",
      "tutorial",
      "student",
      "teacher",
    ],
  };

  // Check which categories match
  for (const [category, keywords] of Object.entries(categoryKeywords)) {
    const matchCount = keywords.filter((keyword) => text.includes(keyword)).length;
    if (matchCount >= 2) {
      suggestions.push(category);
    }
  }

  return suggestions.slice(0, 3); // Return top 3 suggestions
}

